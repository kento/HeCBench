
    // Create execution dnnl::engine for GPU.
    dnnl::engine engine(dnnl::engine::kind::gpu, 0);

    // Create dnnl::stream.
    dnnl::stream engine_stream(engine);

    // Tensor dimensions.
    const memory::dim B = N, // batch size
                      IC = C, // input channels
                      IH = Hin, // input height
                      IW = Win, // input width
                      OC = M, // output channels
                      KH = K, // weights height
                      KW = K, // weights width
                      PH_L = 0, // height padding: left
                      PH_R = 0, // height padding: right
                      PW_L = 0, // width padding: left
                      PW_R = 0, // width padding: right
                      SH = 1, // height-wise stride
                      SW = 1, // width-wise stride
                      OH = (IH - KH + PH_L + PH_R) / SH + 1, // output height
                      OW = (IW - KW + PW_L + PW_R) / SW + 1; // output width

    // Source (src), weights, bias, and destination (dst) tensors
    // dimensions.
    memory::dims src_dims = {B, IC, IH, IW};
    memory::dims weights_dims = {OC, IC, KH, KW};
    memory::dims bias_dims = {OC};
    memory::dims dst_dims = {B, OC, OH, OW};

    // Strides, padding dimensions.
    memory::dims strides_dims = {SH, SW};
    memory::dims padding_dims_l = {PH_L, PW_L};
    memory::dims padding_dims_r = {PH_R, PW_R};

    // Create memory objects for tensor data (src, weights, dst). In this
    // example, NCHW layout is assumed for src and dst, and OIHW for weights.
    auto user_src_mem = memory({src_dims, dt::f32, tag::nchw}, engine);
    auto user_weights_mem = memory({weights_dims, dt::f32, tag::oihw}, engine);
    auto user_dst_mem = memory({dst_dims, dt::f32, tag::nchw}, engine);

    // Create memory descriptors with format_tag::any for the primitive. This
    // enables the convolution primitive to choose memory layouts for an
    // optimized primitive implementation, and these layouts may differ from the
    // ones provided by the user.
    auto conv_src_md = memory::desc(src_dims, dt::f32, tag::any);
    auto conv_weights_md = memory::desc(weights_dims, dt::f32, tag::any);
    auto conv_dst_md = memory::desc(dst_dims, dt::f32, tag::any);

    // Create memory descriptor and memory object for input bias.
    //auto user_bias_md = memory::desc(bias_dims, dt::f32, tag::a);
    //auto user_bias_mem = memory(user_bias_md, engine);

    // Write data to memory object's handle.
    write_to_dnnl_memory(X, user_src_mem);
    write_to_dnnl_memory(W, user_weights_mem);

    // Create primitive descriptor (no bias)
    auto conv_pd = convolution_forward::primitive_desc(engine,
            prop_kind::forward_training, algorithm::convolution_direct,
            conv_src_md, conv_weights_md, conv_dst_md,
            strides_dims, padding_dims_l, padding_dims_r);

    // For now, assume that the src, weights, and dst memory layouts generated
    // by the primitive and the ones provided by the user are identical.
    auto conv_src_mem = user_src_mem;
    auto conv_weights_mem = user_weights_mem;
    auto conv_dst_mem = user_dst_mem;

    // Reorder the data in case the src and weights memory layouts generated by
    // the primitive and the ones provided by the user are different. In this
    // case, we create additional memory objects with internal buffers that will
    // contain the reordered data. The data in dst will be reordered after the
    // convolution computation has finalized.
    if (conv_pd.src_desc() != user_src_mem.get_desc()) {
        conv_src_mem = memory(conv_pd.src_desc(), engine);
        reorder(user_src_mem, conv_src_mem)
                .execute(engine_stream, user_src_mem, conv_src_mem);
    }

    if (conv_pd.weights_desc() != user_weights_mem.get_desc()) {
        conv_weights_mem = memory(conv_pd.weights_desc(), engine);
        reorder(user_weights_mem, conv_weights_mem)
                .execute(engine_stream, user_weights_mem, conv_weights_mem);
    }

    if (conv_pd.dst_desc() != user_dst_mem.get_desc()) {
        conv_dst_mem = memory(conv_pd.dst_desc(), engine);
    }

    // Create the primitive.
    auto conv_prim = convolution_forward(conv_pd);

    // Primitive arguments.
    std::unordered_map<int, memory> conv_args;
    conv_args.insert({DNNL_ARG_SRC, conv_src_mem});
    conv_args.insert({DNNL_ARG_WEIGHTS, conv_weights_mem});
    conv_args.insert({DNNL_ARG_DST, conv_dst_mem});

    start = std::chrono::steady_clock::now();

    for (int i = 0; i < repeat; i++) {
      // Primitive execution: convolution
      conv_prim.execute(engine_stream, conv_args);

      // Reorder the data in case the dst memory descriptor generated by the
      // primitive and the one provided by the user are different.
      if (conv_pd.dst_desc() != user_dst_mem.get_desc()) {
          reorder(conv_dst_mem, user_dst_mem)
                  .execute(engine_stream, conv_dst_mem, user_dst_mem);
      } else
          user_dst_mem = conv_dst_mem;
    }

    // Wait for the computation to finalize.
    engine_stream.wait();
    end = std::chrono::steady_clock::now();
    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();
    printf("Average kernel execution time of conv3d_s4 kernel: %f (us)\n",
           (time * 1e-3f) / repeat);

    // Read data from memory object's handle.
    read_from_dnnl_memory(Y, user_dst_mem);

